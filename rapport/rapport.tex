\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{bookman}
\usepackage{xcolor}
\usepackage{array}
\usepackage{pifont}
\usepackage{ulem}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{eurosym}
\usepackage[left=2cm, right=2cm, top=2cm, bottom=2cm]{geometry}
\usepackage{bm}
\frenchbsetup{StandardLists=true}
\newcommand\coord[3]{
\begin{pmatrix}
#1 \\
#2 \\
#3
\end{pmatrix}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\B}{\mathbb{B}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\D}{\mathbb{D}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\K}{\mathbb{K}}
\newcommand{\lra}{\Longrightarrow}
\newcommand{\lla}{\Longleftarrow}
\newcommand{\llra}{\Longleftrightarrow}
\newcommand{\slra}{\leftrightarrow}
\newcommand{\ra}{\rightarrow}
\newcommand{\la}{\leftarrow}

\setlength{\textheight}{23.5cm}
\def\arraystretch{1.4}

\let\oldtextbf\textbf
\renewcommand{\textbf}[1]{\textcolor{orange}{\oldtextbf{#1}}}
\let\oldunderline\underline{}
\renewcommand{\underline}[1]{\textcolor{purple}{\oldunderline{#1}}}
\let\oldtextit\textit
\renewcommand{\textit}[1]{\textcolor{violet}{\oldtextit{#1}}}

\newcommand{\csection}[1]{\textcolor{red}{\section{#1}}}
\newcommand{\csubsection}[1]{\textcolor{cyan}{\subsection{#1}}}
\newcommand{\csubsubsection}[1]{\textcolor{orange}{\subsubsection{#1}}}

\lstset{inputencoding=utf8,
    extendedchars=true,
    literate=%
    {é}{{\'{e}}}1
    {è}{{\`{e}}}1
    {ê}{{\^{e}}}1
    {ë}{{\¨{e}}}1
    {û}{{\^{u}}}1
    {ù}{{\`{u}}}1
    {â}{{\^{a}}}1
    {à}{{\`{a}}}1
    {î}{{\^{i}}}1
    {ô}{{\^{o}}}1
    {ç}{{\c{c}}}1
    {Ç}{{\c{C}}}1
    {É}{{\'{E}}}1
    {Ê}{{\^{E}}}1
    {À}{{\`{A}}}1
    {Â}{{\^{A}}}1
    {Î}{{\^{I}}}1,
    basicstyle=\footnotesize\sffamily\color{black},
    commentstyle=\textcolor{gray},
    numbers=left,
    numbersep=5pt,
    numberstyle=\textcolor{gray},
    keywordstyle=\textcolor{teal},
    showspaces=false,
    showstringspaces=false,
    stringstyle=\textcolor{magenta},
    tabsize=2
}

\title{Rapport du projet de compilateur SCALPA}
\author{Danyl El-Kabir\\Jérémy Bach\\Nadjib Belaribi\\François Grabenstaetter}

\begin{document}
\sffamily
\everymath{\displaystyle}
\setlength\parindent{0mm}
\setlength{\parskip}{0.2cm}
\maketitle

\begin{center}
    \includegraphics[scale=0.8]{img/scalpa.png}
\end{center}

\newpage
\tableofcontents
\newpage

\csection{Résumé}

L'objectif de ce rapport est de résumer les capacités de notre compilateur SCALPA. Le compilateur génère du code MIPS à partir d'un pseudo code Pascal appellé SCALPA. Nous avons réalisé ce projet de manière incrémentale, en implémentant les différentes fonctions au fur et à mesure.

\csection{Développement du compilateur}

Comme cité précédemment, le développement de ce compilateur s'est fait de manière incrémentale en augmentant petit à petit les capacités du compilateur (en étendant la grammaire).

Dans un premier temps, nous avons réalisé l'analyser lexicale permettant d'analyser un programme SCALPA.

Ensuite, nous avons limité le compilateur aux opérations arithmétiques ainsi que les affectations des variables. Cette version minimale de la grammaire nous à permis de générer notre premier code MIPS et de pouvoir partir sur de bonnes bases.

Une fois cette première étape complètement terminée, nous avons pu élaborer un jeu de tests pour les affectations et les opérations arithmétiques pour enfin ajouter de nouvelles fonctionnalités aux compilateur en étendant davantage la grammaire.

C'est ainsi que nous avons ajouté le support des conditions avec les variables booléennes. L'ajout de ces conditions nous a permis d'ajouter le support des boucles while également.

Par la suite, nous avons étendu la grammaire avec l'ajout du support des tableaux et des fonctions, tout en testant régulièrement nos implémentations.

Après avoir testé le bon fonctionnement du compilateur dans sa plus grande partie, nous avons ajouté un module d'optimisation de code.

\csection{Spécification complète de notre compilateur SCALPA}

Le compilateur est donc capable de générer un programme MIPS R2000 (utilisable sur un simulateur de processeur comme SPIM ou Mars) à partir d'un programme écrit en SCALPA.

Voici une liste non exhaustive des capacités de notre compilateur SCALPA:

\begin{tabular}{c}
  \hline
  Expressions arithmétiques et affectations \\
  \hline
  Affectations et opérations sur les entiers \\
  Opérateur & Support & Commentaire \\
  := & X & Affectation entière\\
  + & X & Addition entière \\
  - & X & Soustraction entière \\
  -(unaire) & X & Moins unaire \\
  * & X & Multiplication \\
  / & X & Division \\
  ^ & X & Opérateur exponentiel \\
  \% & X & Modulo \\
  < ou > & X & Comparaisons entières strictes \\
  <= ou >= & X & Comparaisons entières \\
  = & X & Egalité entières \\
  <> & X & Différence entière \\
  Affectations et opérations sur les booleens \\
  := & X & Affectation booléenne \\
  and & X & Opération AND \\
  or & X & Opération OR \\
  xor & X & Opération XOR \\
  not & X & Opération NOT \\
  \hline
\end{tabular}

\begin{tabular}{c}
  \hline
  Structures de controles\\
  \hline
  Structure & Support & Commentaire \\
  if expr then instr & X & Conditionnelle simple \\
  if expr then instr else instr & X & Conditionnelle avec else \\
  while expr do instr & X & Conditionnelle while \\
  \hline
\end{tabular}


\begin{tabular}{c}
  \hline
  Fonctionnalités des tableaux multidimensionnels \\
  \hline
  Instruction & Support & Commentaire \\
  array[-x1..y1, x2..y2] of type & X & Définition avec index et intervales \\
  tabe[i,j]:=x & X & Affectation à une case d'un tableau \\
  \hline
\end{tabular}

Le programme écrit en SCALPA peut donc supporter :
\begin{itemize}
    \item Des affectations d'entiers et booléens sur des variables ou des cases de tableaux.
    \item Des opérations sur les entiers ou des variables entières (additions, multiplications, soustraction, division, modulo, puissance) tout en respectant les priorités de calcul. (opérations fonctionnelles avec les tableaux comme par exemple tab$[i]$ + tab$[j]$ ou encore tab[i,j,k] * tab[l,m,n] (tableaux multidimensionnels))
    \item Des opérations sur les variables booleennes ou des constantes booleennes (OR, AND, XOR, NOT, opérations fonctionnelles avec les tableaux comme par exemple tab$[i]$ xor tab$[j]$)
    \item Les opérations de comparaisons sur les entiers sont également implémentés et peuvent être utilisés comme conditions (<, >, <=, >=, =, <>, opérations fonctionnelles avec les tableaux comme par exemple tab$[i]$ xor tab$[j]$)
    \item Des opérations sur des fonctions, fonctions récursives avec un passage de paramètres par valeur et par référence.

\end{itemize}

Ces opérations de comparaisons permettent de créer des conditions de type \textit{if cond then instr else instr } ou \textit{while cond do instr}. Les conditions sont implémentées et permettent de réaliser toutes sortes de boucles. Les conditions peuvent être des comparaisons sur des entiers, ou des opérations sur des booleens par exemple.
Nous pouvons également imbriquer les conditions pour vérifier plusieurs assertions par exemple et distinguer des cas.
Il est possible de simuler une boucle for avec un while, mais il aurait cependant été possible de l'implémenter directement.

En ce qui concerne les tableaux, ils sont entièrement fonctionnels et permettent de faire des affectations ou des opérations sur des éléments du tableau en fonction du type de varaible du tableau. Les tableaux peuvent contenir des booleens ou des entiers et sont déclarés avec des intervales, ces intervales corresspondent aux index du tableau sur les dimensions.

Les tableaux à multidimensions sont également fonctionnels à condition d'avoir le même type dans toutes les cases. Le contenu d'une case du tableau est interprété comme une variable de ce même type et permet donc de formuler des conditions et des opérations sur un contenu du tableau.

De plus l'analyse lexicale de notre compilateur se fait sans sensibilité à la casse, ce qui laisse une "marge d'erreur" au programmeur, s'il se trompe et écrit While, wHile ou whiLE...etc ce n'est pas grave notre compilateur saura comprendre son code.

Pour finir, les fonctions peuvent être définies et utilisées dans le programme tout en prenant des arguments en entrée et en retournant des valeurs.
Les arguemnts des fonctions peuvent être des entiers, des booleens ou des tableaux. Les tableaux peuvent être passés en copie ou en référence. Si le tableau est passé en argument par référence, la fonction modifiera le tableau par effet de bord sur le tableau inital. Les fonctions récursives sont également suportées et complètement fonctionelles.

\end{document}
