\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{bookman}
\usepackage{xcolor}
\usepackage{array}
\usepackage{pifont}
\usepackage{ulem}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{eurosym}
\usepackage[left=2cm, right=2cm, top=2cm, bottom=2cm]{geometry}
\usepackage{bm}
\frenchbsetup{StandardLists=true}
\newcommand\coord[3]{
\begin{pmatrix}
#1 \\
#2 \\
#3
\end{pmatrix}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\B}{\mathbb{B}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\D}{\mathbb{D}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\K}{\mathbb{K}}
\newcommand{\lra}{\Longrightarrow}
\newcommand{\lla}{\Longleftarrow}
\newcommand{\llra}{\Longleftrightarrow}
\newcommand{\slra}{\leftrightarrow}
\newcommand{\ra}{\rightarrow}
\newcommand{\la}{\leftarrow}

\setlength{\textheight}{23.5cm}
\def\arraystretch{1.4}

\let\oldtextbf\textbf
\renewcommand{\textbf}[1]{\textcolor{orange}{\oldtextbf{#1}}}
\let\oldunderline\underline{}
\renewcommand{\underline}[1]{\textcolor{purple}{\oldunderline{#1}}}
\let\oldtextit\textit
\renewcommand{\textit}[1]{\textcolor{violet}{\oldtextit{#1}}}

\newcommand{\csection}[1]{\textcolor{red}{\section{#1}}}
\newcommand{\csubsection}[1]{\textcolor{cyan}{\subsection{#1}}}
\newcommand{\csubsubsection}[1]{\textcolor{orange}{\subsubsection{#1}}}

\lstset{inputencoding=utf8,
    extendedchars=true,
    literate=%
    {é}{{\'{e}}}1
    {è}{{\`{e}}}1
    {ê}{{\^{e}}}1
    {ë}{{\¨{e}}}1
    {û}{{\^{u}}}1
    {ù}{{\`{u}}}1
    {â}{{\^{a}}}1
    {à}{{\`{a}}}1
    {î}{{\^{i}}}1
    {ô}{{\^{o}}}1
    {ç}{{\c{c}}}1
    {Ç}{{\c{C}}}1
    {É}{{\'{E}}}1
    {Ê}{{\^{E}}}1
    {À}{{\`{A}}}1
    {Â}{{\^{A}}}1
    {Î}{{\^{I}}}1,
    basicstyle=\footnotesize\sffamily\color{black},
    commentstyle=\textcolor{gray},
    numbers=left,
    numbersep=5pt,
    numberstyle=\textcolor{gray},
    keywordstyle=\textcolor{teal},
    showspaces=false,
    showstringspaces=false,
    stringstyle=\textcolor{magenta},
    tabsize=2
}

\title{Rapport du projet de compilateur SCALPA}
\author{Danyl El-Kabir\\Jérémy Bach\\Nadjib Belaribi\\François Grabenstaetter}

\begin{document}
\sffamily
\everymath{\displaystyle}
\setlength\parindent{0mm}
\setlength{\parskip}{0.2cm}
\maketitle

\begin{center}
    \includegraphics[scale=0.8]{img/scalpa.png}
\end{center}

\newpage
\tableofcontents
\newpage

\csection{Introduction}

L'objectif de ce rapport est de résumer les capacités de notre compilateur SCALPA. Le compilateur génère du code MIPS à partir d'un code SCALPA. Nous avons réalisé ce projet de manière incrémentale, en implémentant les différentes fonctions au fur et à mesure.

Le projet a donc été séparé en sous taches :
- Analyse lexicale
- Implémentation des affectations et opérations arithmétiques
- Implémentation des conditions
- Implémentation des boucles
- Implémentation des tableaux
- Implémentation des fonctions

Chaque sous partie peut être représentée comme un sprint dans une méthode de travail agile.
En effet, nous avons commencé à développer le compilateur pour qu'il se limite aux affectations de variables ainsi que sur les opérations sur les entiers. Cette étape cruciale nous a permis de nous familiariser avec les mécanismes de génération de code par exemple.
Après avoir implémenté les affectations et opérations arithmétiques, nous avons testé le compiateur via un jeu de test. Dès que la sous partie fut finie, nous avons pu passer à la prochaine phase du projet avec l'Implémentation des conditions.

C'est ansi que s'est déroulé le developpement de ce compilateur en enchainant systématiquement les phases d'analyses lexicale, syntaxique, de génération de code et de test pour chaque sous partie.

\csection{Capacités de notre compilateur}

Le compilateur est donc capable de générer un programme MIPS R2000 (utilisable sur un simulateur de processeur comme SPIM ou Mars) à partir d'un programme écrit en SCALPA.
Le programme écrit en SCALPA peut donc supporter :
\begin{itemize}
    \item Des affectations sur les entiers, les booleens et les chaines de caractères
    \item Des opérations sur les entiers ou des variables entières (additions, multiplications, soustraction, division, puissance) tout en respectant les priorités de calcul.
    \item Des opérations sur les variables booleennes ou des constantes booleennes (OR, AND, XOR, NOT)
    \item Les opérations de comparaisons sur les entiers sont également implémentés et peuvent être utilisés comme conditions (<, >, <=, >=, =, <>)
\end{itemize}

Ces opérations de comparaisons permettent de créer des conditions de type \textit{if cond then instr else instr } ou \textit{while cond do instr}. Les conditions sont implémentées et permettent de réaliser toutes sortes de boucles. Les conditions peuvent être des comparaisons sur des entiers, ou des opérations sur des booleens par exemple.
Nous pouvons également imbriquer les conditions pour vérifier plusieurs assertions par exemple et distinguer des cas.
Il est possible de simuler une boucle for avec un while, mais il aurait cependant été possible de l'implémenter directement.

En ce qui concerne les tableaux, ils sont entièrement fonctionnels et permettent de faire des affectations ou des opérations sur des éléments du tableau en fonction du type de varaible du tableau. Les tableaux peuvent contenir des booleens ou des entiers et sont déclarés avec des intervales, ces intervales corresspondent aux index du tableau sur les dimensions.

Les tableaux à multidimensions sont également fonctionnels à condition d'avoir le même type dans toutes les cases. Le contenu d'une case du tableau est interprété comme une variable de ce même type et permet donc de formuler des conditions et des opérations sur un contenu du tableau.

De plus l'analyse lexicale de notre compilateur se fait sans sensibilité à la casse, ce qui laisse une "marge d'erreur" au programmeur, s'il se trompe et écrit While, wHile ou whiLE...etc ce n'est pas grave notre compilateur saura comprendre son code.

Pour finir, les fonctions peuvent être définies et utilisées dans le programme tout en prenant des arguments en entrée et en retournant des valeurs.
Les arguemnts des fonctions peuvent être des entiers, des booleens ou des tableaux. Les tableaux peuvent être passés en copie ou en référence. Si le tableau est passé en argument par référence, la fonction modifiera le tableau par effet de bord sur le tableau inital. Les fonctions récursives sont également suportées et complètement fonctionelles.

\end{document}
