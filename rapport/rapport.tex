\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{bookman}
\usepackage{xcolor}
\usepackage{array}
\usepackage{pifont}
\usepackage{ulem}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{eurosym}
\usepackage[left=2cm, right=2cm, top=2cm, bottom=2cm]{geometry}
\usepackage{bm}
\frenchbsetup{StandardLists=true}
\newcommand\coord[3]{
\begin{pmatrix}
#1 \\
#2 \\
#3
\end{pmatrix}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\B}{\mathbb{B}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\D}{\mathbb{D}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\K}{\mathbb{K}}
\newcommand{\lra}{\Longrightarrow}
\newcommand{\lla}{\Longleftarrow}
\newcommand{\llra}{\Longleftrightarrow}
\newcommand{\slra}{\leftrightarrow}
\newcommand{\ra}{\rightarrow}
\newcommand{\la}{\leftarrow}

\setlength{\textheight}{23.5cm}
\def\arraystretch{1.4}

\let\oldtextbf\textbf
\renewcommand{\textbf}[1]{\textcolor{orange}{\oldtextbf{#1}}}
\let\oldunderline\underline{}
\renewcommand{\underline}[1]{\textcolor{purple}{\oldunderline{#1}}}
\let\oldtextit\textit
\renewcommand{\textit}[1]{\textcolor{violet}{\oldtextit{#1}}}

\newcommand{\csection}[1]{\textcolor{red}{\section{#1}}}
\newcommand{\csubsection}[1]{\textcolor{cyan}{\subsection{#1}}}
\newcommand{\csubsubsection}[1]{\textcolor{orange}{\subsubsection{#1}}}

\lstset{inputencoding=utf8,
    extendedchars=true,
    literate=%
    {é}{{\'{e}}}1
    {è}{{\`{e}}}1
    {ê}{{\^{e}}}1
    {ë}{{\¨{e}}}1
    {û}{{\^{u}}}1
    {ù}{{\`{u}}}1
    {â}{{\^{a}}}1
    {à}{{\`{a}}}1
    {î}{{\^{i}}}1
    {ô}{{\^{o}}}1
    {ç}{{\c{c}}}1
    {Ç}{{\c{C}}}1
    {É}{{\'{E}}}1
    {Ê}{{\^{E}}}1
    {À}{{\`{A}}}1
    {Â}{{\^{A}}}1
    {Î}{{\^{I}}}1,
    basicstyle=\footnotesize\sffamily\color{black},
    commentstyle=\textcolor{gray},
    numbers=left,
    numbersep=5pt,
    numberstyle=\textcolor{gray},
    keywordstyle=\textcolor{teal},
    showspaces=false,
    showstringspaces=false,
    stringstyle=\textcolor{magenta},
    tabsize=2
}

\title{Rapport du projet de compilateur SCALPA}
\author{Danyl El-Kabir\\Jérémy Bach\\Nadjib Belaribi\\François Grabenstaetter}

\begin{document}
\sffamily
\everymath{\displaystyle}
\setlength\parindent{0mm}
\setlength{\parskip}{0.2cm}
\maketitle

\begin{center}
    \includegraphics[scale=0.8]{img/scalpa.png}
\end{center}

\newpage
\tableofcontents
\newpage

\csection{Résumé}

L'objectif de ce rapport est de résumer les capacités de notre compilateur SCALPA. Le compilateur génère du code MIPS à partir d'un pseudo code Pascal appellé SCALPA. Nous avons réalisé ce projet de manière incrémentale, en implémentant les différentes fonctions au fur et à mesure.

\csection{Développement du compilateur}

Comme cité précédemment, le développement de ce compilateur s'est fait de manière incrémentale en augmentant petit à petit les capacités du compilateur (en étendant la grammaire).

Dans un premier temps, nous avons réalisé l'analyser lexicale permettant d'analyser un programme SCALPA.

Ensuite, nous avons limité le compilateur aux opérations arithmétiques ainsi que les affectations des variables. Cette version minimale de la grammaire nous à permis de générer notre premier code MIPS et de pouvoir partir sur de bonnes bases.

Une fois cette première étape complètement terminée, nous avons pu élaborer un jeu de tests pour les affectations et les opérations arithmétiques pour enfin ajouter de nouvelles fonctionnalités aux compilateur en étendant davantage la grammaire.

C'est ainsi que nous avons ajouté le support des conditions avec les variables booléennes. L'ajout de ces conditions nous a permis d'ajouter le support des boucles while également.

Par la suite, nous avons étendu la grammaire avec l'ajout du support des tableaux et des fonctions, tout en testant régulièrement nos implémentations.

Après avoir testé le bon fonctionnement du compilateur dans sa plus grande partie, nous avons ajouté un module d'optimisation de code.

\clearpage

\csection{Spécification complète de notre compilateur SCALPA}

Le compilateur est donc capable de générer un programme MIPS R2000 (utilisable sur un simulateur de processeur comme SPIM ou Mars) à partir d'un programme écrit en SCALPA.

Voici une liste non exhaustive des capacités de notre compilateur SCALPA:

\begin{center}
\begin{tabular}{|l|l|l|}
  \hline
  \multicolumn{3}{|c|}{Expressions arithmétiques et affectations} \\
  \hline
  Opérateur & Support & Commentaire \\
  \hline
  \multicolumn{3}{|c|}{Déclartions de variables} \\
  \hline
  var a, b: type & X & Déclaration multiple \\
  \hline
  \multicolumn{3}{|c|}{Affectations et opérations sur les entiers} \\
  \hline
  := & X & Affectation entière\\
  + & X & Addition entière \\
  - & X & Soustraction entière \\
  -(unaire) & X & Moins unaire \\
  * & X & Multiplication \\
  / & X & Division \\
  $\wedge$ & X & Opérateur exponentiel \\
  \% & X & Modulo \\
  < ou > & X & Comparaisons entières strictes \\
  <= ou >= & X & Comparaisons entières \\
  = & X & Egalité entières \\
  <> & X & Différence entière \\
  \hline
  \multicolumn{3}{|c|}{Affectations et opérations sur les booleens} \\
  \hline
  := & X & Affectation booléenne \\
  and & X & Opération AND \\
  or & X & Opération OR \\
  xor & X & Opération XOR \\
  not & X & Opération NOT \\
  \hline
\end{tabular}

\begin{tabular}{|l|l|l|}
  \hline
  \multicolumn{3}{|c|}{Structures de controle} \\
  \hline
  Structure & Support & Commentaire \\
  \hline
  if expr then instr & X & Conditionnelle simple \\
  if expr then instr else instr & X & Conditionnelle avec else \\
  while expr do instr & X & Conditionnelle while \\
  & & expr peut être une condtion sur \\
  & & des booléens ou des entiers \\
  \hline
\end{tabular}


\begin{tabular}{|l|l|l|}
  \hline
  \multicolumn{3}{|c|}{Fonctionnalités des tableaux multidimensionnels} \\
  \hline
  Instruction & Support & Commentaire \\
  \hline
  array $[$-x..y$]$ of type & X & Déclaration avec index et intervales \\
  array $[$-x1..y1, -x2..y2, -x3..y3 $]$ of type & X & Déclaration multidimensionnelle \\
  tab$[$i,j$]$:=x & X & Affectation à une case d'un tableau \\
  tab$[$i,j$]$:=tab$[$k,l$]$ & X & Affectation à partir d'un tableau \\
  tab$[$i,j$]$ < tab$[$i,j$]$ & X & Comparaisons sur les éléments de tableaux \\
  tab$[$i,j$]$ or tab$[$i,j$]$ & X & Opérations booléennes sur les éléments de tableaux \\
  \hline
\end{tabular}

\begin{tabular}{|l|l|l|}
  \hline
  \multicolumn{3}{|c|}{Fonctionnalités des fonctions} \\
  \hline
  Instruction & Support & Commentaire \\
  \hline
  function max (a: int, b: int): int  & X & Déclaration avec argument\\
  & & et valeur de retour \\
  function bsort (ref tab : array[1..10] & X & Passage d'un tableau en argument \\
  of int, size : int) : unit  & & via référence (effet de bord)\\
  function bsort (tab : array[1..10] of int, & X & Passage d'un tableau en argument \\
   size : int) : unit  & & via copie \\
  Fonctions récursives & X & \\
  \hline
\end{tabular}

\begin{tabular}{|l|l|l|}
  \hline
  \multicolumn{3}{|c|}{Commentaires} \\
  \hline
  Instruction & Support & Commentaire \\
  \hline
  (* *) & X & Commentaires simples \\
  (* (* *) *) & X & Commentaires imbriqués \\
  \hline
\end{tabular}

\begin{tabular}{|l|l|l|}
  \hline
  \multicolumn{3}{|c|}{Fonctions prédéfinies} \\
  \hline
  Instruction & Support & Commentaire \\
  \hline
  read var & X & Lecture d'une entrée dans une variable \\
  write var & X & Affichage de la variable dans la console \\
  write "str" & X & Affichage de constantes dans la console \\
  write tab[i] ou read tab[i] & X & Opérations prédéfinies sur les tableaux \\
  \hline
\end{tabular}

\end{center}

De plus l'analyse lexicale de notre compilateur se fait sans sensibilité à la casse, ce qui laisse une "marge d'erreur" au programmeur, s'il se trompe et écrit While, wHile ou whiLE...etc ce n'est pas grave notre compilateur saura comprendre son code.

Il est également important de noter que les opérations sur entiers respectent l'ordre de priotités usuel sans avoir besoin de forcer l'ordre avec des parenthèses.

\end{document}
